package qaengineerweb2024;

import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/*
Задание 4
Аня пришла в новый офис и пока плохо ориентируется в нем. Из-за этого она иногда посещает одни и те же места дважды, пытаясь дойти от точки А до точки В. Аня получит статус знатока офиса, когда сможет пройти от входа до своего рабочего места, не посещая никакое помещение офиса дважды.
Напишите программу, которая определяет, прошла Аня маршрут оптимально или нет.
Карта офиса представляет собой клетчатую сетку, Аня умеет ходить в помещение слева (L), в помещение спереди (U), в помещение справа (R) или в помещение позади (D). Каждое свое перемещение Аня записывает на листочке, чтобы потом отдать вам на проверку. Аня стартует со входа в офис и заканчивает маршрут у своего рабочего места.
Помогите Ане определить оптимальность своего маршрута и выведите «YES», если в маршруте
Ани есть повторяющиеся помещения, и «NO» в противном случае.

Формат входных данных
В первой строке дана длина маршрута Ани N (1 ≤ N ≤ 2 • 10^5). Во второй строке дан сам маршрут в виде строки длины N, состоящей из букв LRUD.

Формат выходных данных
Если маршрут Ани самопересекается, то выведите «YES» (без кавычек), в противном случае выведите «NO».

Примеры данных
Пример 1
Ввод
4
DLUL
вывод
NO

Пример 2
Ввод
7
DLLURDD
вывод
YES
 */
public class OfficeRoute {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Чтение длины маршрута
        int n = scanner.nextInt();
        // Проверка на соответствие диапазону
        if (n < 1 || n > 2 * Math.pow(10, 5)) {
            System.out.println("Недопустимая длина маршрута.");
            return;
        }
        scanner.nextLine(); // Чтение символа новой строки после числа

        // Чтение маршрута
        String route = scanner.nextLine().trim();

        // Проверка на оптимальность маршрута
        String result = isOptimalRoute(route) ? "NO" : "YES";
        System.out.println(result);

        // Закрытие сканнера
        scanner.close();
    }

    // Метод для проверки оптимальности маршрута
    private static boolean isOptimalRoute(String route) {
        Set<String> visitedRooms = new HashSet<>();
        int x = 0, y = 0; // Начальные координаты входа в офис

        // Изначально вход в офис помечаем как посещенный
        visitedRooms.add(x + "," + y);

        // Обходим каждый шаг маршрута
        for (char step : route.toCharArray()) {
            switch (step) {
                case 'L':
                    x--;
                    break;
                case 'R':
                    x++;
                    break;
                case 'U':
                    y++;
                    break;
                case 'D':
                    y--;
                    break;
            }

            // Если текущее помещение уже посещено, маршрут не оптимален
            if (!visitedRooms.add(x + "," + y)) {
                return false;
            }
        }

        // Если все шаги маршрута пройдены и нет повторяющихся помещений, маршрут оптимален
        return true;
    }
}
