package qasummer2024;





/*
Задача 4
В одной из предыдущих задач требовалось вывести перевернутую матрицу, теперь задача усложняется:
При этом поворот необходимо осуществлять in-place, т. е. без выделения дополнительной памяти.
Для этого вместо результирующей матрицы необходимо вывести последовательность операций. За одну операцию можно обменять местами два элемента матрицы.
Вам дана матрица n х n, а так же указано, надо ли повернуть изображение по часовой R или против часовой L стрелки. Выведите последовательность операций, чтобы исходная матрица повернулась на 90 градусов в указанном направлении.
Заметьте, что необязательно переставлять элементы в том порядке, в котором происходил бы поворот, главное чтобы в результате матрица соответствовала повороту на 90 градусов. Также необязательно, чтобы количество операций было минимальным, нужно только вписаться в ограничения.
Формат входных данных
Первая строка содержит одно натуральное число n (1 ≤ n < 10^3) и указание направления поворота - символ R или L. Следующие п строк содержат описание матрицы, по п целых неотрицательных чисел, не превосходящих 10^18
Формат выходных данных
В первой строке выведите число k — необходимое количество операций, при этом это число не должно превосходить 7n^2. В последующих k строках выведите по две пары чисел — координаты (х_1, У_1) и (х_2, У_2) ячеек, между которыми необходимо обменять элементы матрицы.
Обратите внимание, что нумерация строк и столбцов матрицы ведётся с 0, а не с 1.
Примеры данных
Пример 1
Ввод
2 L
0 0
0 1
Вывод
1
1 1 0 1
Пример 2
Ввод
3 R
0 1 0
1 0 0
4 3 0
Вывод
3
1 0 1 2
0 0 2 0
1 0 2 1
Пример 3
Ввод
1 L
5
Вывод
0
 */

import java.util.Scanner;

public class ForthTask {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        char direction = scanner.next().charAt(0);

        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = scanner.nextLong();
            }
        }

        rotateMatrix(matrix, direction);
    }

    public static void rotateMatrix(long[][] matrix, char direction) {
        int n = matrix.length;
        int operationsCount = 0;

        // Поворот по часовой стрелке
        if (direction == 'R') {
            // Обмен элементов симметрично относительно главной диагонали
            for (int i = 0; i < n; i++) {
                for (int j = i + 1; j < n; j++) {
                    System.out.println((i + 1) + " " + (j + 1) + " " + (j + 1) + " " + (i + 1));
                    operationsCount += 1;
                }
            }

            // Обмен элементов в каждой строке, симметрично относительно вертикальной середины матрицы
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n / 2; j++) {
                    System.out.println((i + 1) + " " + (j + 1) + " " + (i + 1) + " " + (n - j));
                    operationsCount += 1;
                }
            }
        }

        // Поворот против часовой стрелки
        else if (direction == 'L') {
            // Обмен элементов симметрично относительно побочной диагонали
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n - 1 - i; j++) {
                    System.out.println((i + 1) + " " + (j + 1) + " " + (n - j) + " " + (n - i));
                    operationsCount += 1;
                }
            }

            // Обмен элементов в каждом столбце, симметрично относительно горизонтальной середины матрицы
            for (int i = 0; i < n / 2; i++) {
                for (int j = 0; j < n; j++) {
                    System.out.println((i + 1) + " " + (j + 1) + " " + (n - i) + " " + (j + 1));
                    operationsCount += 1;
                }
            }
        }

        System.out.println(operationsCount);
    }
}
