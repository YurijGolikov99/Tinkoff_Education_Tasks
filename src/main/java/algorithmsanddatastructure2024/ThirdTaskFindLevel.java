package algorithmsanddatastructure2024;

import java.util.Scanner;

/*
^ - степень
_ - нижний индекс
Мария занимается строительством города в известной мобильной игре.
Каждый район города имеет свою целочисленную высоту над поверхностью ai. В этой игре проходит ровно одна дорога, которая соединяет собой п районов этого города. Дорога плавно
преодолевает перепады высот в городе. Например, если два соседних района і и і + 1 имеют разные высоты х и у (х < у), то дорога плавно поднимается от района і к району і + 1. Точно так же
дорога может спускаться.
Сегодня Маша узнала, что наконец может превратить дорогу в автомобильную магистраль. В отличие от обычной дороги, магистраль проходит на одном и том же расстоянии от поверхности во всех районах.
Мария хочет перестроить имеющуюся у нее дорогу в магистраль таким образом, чтобы суммарный уровень дороги во всех точках не изменился. То есть она хочет выбрать такую высоту магистрали, чтобы суммарная площадь в разрезе на которую придется поднять некоторые участки дороги была равна суммарной площади, на которую нужно будет опустить другие участки дороги.
Помогите Маше и найдите уровень над поверхностью, на котором необходимо построить магистраль.

Формат входных данных
В первой строке входных данных дано одно число n — число районов в городе (1 ≤ n < 5•10^5).
Во второй строке дано n целых чисел ai — уровни районов города (0 < ai < 10^5).

Формат выходных данных
Выведите единственное вещественное число — ответ на задачу. Точность ответа должна быть не меньше 10^-4.

Система оценки
Баллы за каждую подзадачу начисляются только в случае, если все тесты этой подзадачи и необходимых подзадач успешно пройдены.


Примеры данных
Пример 1
Ввод
3
1 2 3
Вывод
2.0

Пример 2
Ввод
4
1 1 1 1
Вывод
1.0

Пример 3
Ввод
4
0 1 1 0
Вывод
0.6666666666666666
 */
public class ThirdTaskFindLevel {
    public static double findMagistralHeight(int[] heights) {
        int n = heights.length;
        int[] prefixSum = new int[n];

        // Вычисляем префиксные суммы высот районов
        prefixSum[0] = heights[0];
        for (int i = 1; i < n; i++) {
            prefixSum[i] = prefixSum[i - 1] + heights[i];
        }

        int totalHeight = prefixSum[n - 1];

        // Перебираем возможные уровни магистрали
        for (double magistralHeight = 0.0; magistralHeight <= totalHeight; magistralHeight += 0.0001) {
            double belowMagistral = 0;
            double aboveMagistral = 0;

            // Вычисляем суммарные высоты ниже и выше текущего уровня магистрали
            for (int i = 0; i < n; i++) {
                if (heights[i] < magistralHeight) {
                    belowMagistral += magistralHeight - heights[i];
                } else {
                    aboveMagistral += heights[i] - magistralHeight;
                }
            }

            // Если суммарные высоты ниже и выше равны с заданной точностью, то это искомый уровень магистрали
            if (Math.abs(belowMagistral - aboveMagistral) < 0.0001) {
                return magistralHeight;
            }
        }

        // Если не найдено подходящего уровня магистрали, вернуть -1
        return -1.0;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Чтение числа районов
        int n = scanner.nextInt();

        // Чтение уровней районов города
        int[] heights = new int[n];
        for (int i = 0; i < n; i++) {
            heights[i] = scanner.nextInt();
        }

        // Закрытие сканнера
        scanner.close();

        // Поиск уровня магистрали
        double magistralHeight = findMagistralHeight(heights);

        if (magistralHeight != -1.0) {
            System.out.printf("%.4f\n", magistralHeight);
        } else {
            System.out.println("Магистраль не может быть построена.");
        }
    }
}
